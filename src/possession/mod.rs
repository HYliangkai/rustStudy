/** 所有权 */

/**
1. 所有权存在的目的是为了管理[堆]数据
  ## 规则
  + 针对堆内存有效
  + 同一时刻一段堆数据只允许存在**一个引用**(直接引用)和多个**借用**(间接引用)
 */
#[test]
pub fn try_possession() {
    let a = 128;
    let b = a;
    println!("{:?}", a); //栈数据在进行赋值的时候直接进行数据的复制,一份变成两份,所以不会发生所有权的转移

    //堆数据在进行赋值的时候是复制 指针值,源数据并不会一份变成两份,而是两个数据指向同一份堆数据. 但是这样会存在不安全的情况发生:当一份数据被两个变量同时持有时可能会出现同时修改的情况,导致bug

    //因此rust只允许 同一时刻只能有一个变量能持有堆内存的指针的权利 --> 称之为所有权,即 : 引用 (tips:是否拥有修改的权利取决于是否有mut声明和所有权归属无关)
    let as_one = String::from("权"); //堆数据的所有权归as_one
                                     //但是确实有需要同时两个变量拥有数据的情况,该如何解决?
                                     // ==》这时候就需要对as_one进行一次引用,然后进行修改, 即: 既然目前只有as_one能修改数据.由于指针存储在栈上,直接赋值的行为相当于copy,那么我只能对as_one进行一次引用,这样获取的值就是指针的指针,不是同一个值,但是进行解引用的时候获取的是as_one,就是以as_one的视角进行数据修改-->这种间接获取所有权的行为,称之为 : 借用
    let as_two = &as_one; //获取到as_one的指针
                          //可以通过 *as_two  / as_one  操作同一份数据
    assert_eq!((*as_two).len(), 3);
    assert_eq!(as_one.is_empty(), false);
    //而直接赋值的行为相当于建立一个新的引用会让as_one失去操作权限
    let as_three = as_one;
    //println!("{:?}", as_one.len()); ==> error :所有权消失
    assert_ne!(as_three.len(), 1)

    //rust通过所有权规则 - 在堆内存的使用权上 - 实现了类似锁的功能
}
