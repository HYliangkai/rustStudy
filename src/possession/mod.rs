/** 所有权 */

/**
1. 所有权存在的目的是为了管理[堆]数据
## 规则
+ 针对堆内存有效
_
 */
#[test]
pub fn try_possession() {
    let a = 128;
    let _b = a;
    println!("{:?}", a); //栈数据在进行赋值的时候直接进行数据的复制,一份变成两份,所以不会发生所有权的转移

    //堆数据在进行赋值的时候是复制 指针值,源数据并不会一份变成两份,而是两个数据指向同一份堆数据. 但是这样会存在不安全的情况发生:当一份数据被两个变量同时持有时可能会出现同时修改的情况,导致bug

    //因此rust只允许 同一时刻只能有一个变量能持有堆内存的指针的权利 --> 称之为所有权
    let as_one = String::from("权"); //堆数据的所有权归as_one
                                     //但是确实有需要同时两个变量拥有数据的情况,该如何解决?
                                     // ==》这时候就需要对as_one进行一次引用,然后进行修改, 即: 既然目前只有as_one能修改数据.由于指针存储在栈上,直接赋值的行为相当于copy,那么我只能对as_one进行一次引用,这样获取的值就是指针的指针,不是同一个值,但是进行解引用的时候获取的是as_one,就是以as_one的视角进行数据修改-->这种间接获取所有权的 [行为] ,称之为 : 借用
    let as_two = &as_one; //获取到as_one的指针
    let _as_two_two = &as_one; //借用可以使用多次
                               //可以通过 *as_two  / as_one  操作同一份数据
    assert_eq!((*as_two).len(), 3);
    assert_eq!(as_one.is_empty(), false);
    //而直接赋值的行为相当于建立一个新的引用会让as_one失去操作权限
    let as_three = as_one;
    //println!("{:?}", as_one.len()); ==> error :所有权消失
    assert_ne!(as_three.len(), 1)

    //rust通过所有权规则 - 在堆内存的使用权上 - 实现了类似锁的功能
}

/** ## 引用和借用的区别
借用是一种数据传递方式，与之相对的概念是拷贝和移动。a借用b，a就可以访问b中的数据，同时被b的生命周期限制。

引用是一种操作内存的数据类型，对应于指针、智能指针等。引用内部存有关于被引用变量的内存位置，定义了解引用、取地址来操作数据和内存。

在rust中，基于某些未知原因，引用是实现借用的唯一方式；同时为了方法悬空引用（即被引用对象早于引用析构，引用指向了已析构的内存。），rust仅允许以借用的方式使用引用  -->所以实际上引用和借用在语法使用上并没有区别

+ 引用是创建一个变量，指向另个指针的地址，而不是直接指向 该指针指向的堆内存地址
+ 使用引用作为函数参数的行为被称作借用,所以借用是动词行为
### 引用的限制
**同一时刻只能存在一个可变引用 or 多个不可变引用**

单纯Rust语言上考虑。 我们在不同情况下解释&的意思：
1. 在表达式上，表示的是借用。
2. 在变量绑定上，表示解地址操作与*类似。
3. 在类型声明上，表示引用类型。
4. *在模式匹配上，无效关键字*

那么ref的通用解释是：
1. 在表达式上，无效关键字。
2. 在变量绑定上，表示引用类型。
3. 在类型声明上，无效关键字。
4. 在模式匹配上，表示引用类型。
 */
pub fn uuse() {
    //显式声明一个引用 : 用 ref 关键字  注意在模式匹配上只能使用ref
    //得到的结果是 &Vec<i32> , 和使用借用关键字 & 效果是一样的
    let ref aaa = vec![12, 3];

    //以下两种操作的效果是一致的
    let b1 = &1;
    let &res1 = b1;
    //  ===
    let b2 = &1;
    let res2 = *b2;
}
