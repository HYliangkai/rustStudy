/**rust 中可能存在的数据形式*/

/**
1. 常量
    + 数据是在编译时确定的
    + 必须显示声明类型
    + 生命周期和程序的生命周期一致,使用时不需要考虑生命周期的问题
    + 只可读不可写
 */
const _MY_LOVE: &str = "原神";

/**
2. 变量
    + rust的变量是默认"不可变"的,这里的不可变指的是对应的 "栈上" 数据不可变,相当于js中的const声明;不同于 js 的 const 的是 rust 中需要修改指针里的内容时必须给编译器打给&mut招呼才可以修改指针所指内容
    + 想要变量可变要在 let 后加一个 mut
     */

/**
2.1. 静态变量
    + 编译时确定的数据
    + 必须显式声明类型
    + 一般用于变量共享
    + 可声明为mut,但是改变值的时候要注意线程安全问题
    + 生命周期和程序的生命周期一致,可以在任何地方访问
    + **static支持可写操作。所有对static的写操作都是unsafe的**
*/
static mut _IP: &str = "127.0.0.1";

/**
2.2 普通变量
    + 运行时确定的数据,所以不能在代码块外面声明
    + 具有生命周期
 */
#[test]
pub fn test_var() {
    let mut js = "123".to_string();
    let _rs = "098".to_string();
    //mut js 表示 js的值可以被修改
    js = "456".to_string();
    //ts存放的是js的指针(在栈上,64位占8字节,32位占4字节)
    //1.如果使用 mut ts ,表示指针的值是可变的,即ts可以指向别的数据
    //2.如果 js是可变(mut)变量,想在ts这边使用解引用在ts端改变js的值,必须先声明 = &mut js ,表示"可变引用",即js可以改变值 ->- 注意⚠️:前提是js 本身声明为 mut 才可使用 &mut

    let ts = &mut js;
    *ts = "789".to_string();
    println!("{:?}", ts)
    //总结 mut必须出现在等值左边  |  &mut必须出现在等值右边,并且前提是源数据为 mut
}

/** rust中可能存在的表达式赋值情况
在Rust程序 里面，表达式可以是语句的一部分，反过来，`语句也可以是表达式的一部分`。
一个表达式总是会产生一个值，因此它必然有类型;
语句不产生值，它的类型永远是()。
如果把一个表达式加上分号，那么它就变成 了一个语句;
如果把语句放到一个语句块中包起来，那么它就可以被当 成一个表达式使用。
*/

#[test]
pub fn expressions() {
    let x = 1;
    let mut y: i32 = 2;
    let z = y = x;
    println!("{:?}", z); //结果为()
                         //原因是这里的情况是先计算语句y=x的值:() 然后赋值给z,所以等于 ()
                         //=> 类似于 let z = (y=x);

    //表达形式1:赋值表达式
    let mut _ep11 = 1024;

    //表达形式2:语句块表达式 : 即:将语句就放置一个语句块中,语句快中最后值就是这个语句快表达式的结果
    //注意:语句快表达式如果想要作为表达式的结果  ,  最后的值是不能加上return的

    //语句块表达式的语法  1.必须以 ; 做结尾   2.不能用return作为表达式的结果 (return的用途是用于做函数返回值的),只能将最后一个值且不以 ; 做结尾的值作为表达式的结果
    let ep2 = { 2048 };
    let ep3 = {
        println!("语句块被执行");
        2333
    };
    //if语句块表达式
    let _ep4: bool = if ep3 > ep2 { true } else { false };
    //loop语句块表达式;返回值是break后面带上的值
    let mut st = 1;
    let _ep5 = loop {
        st += 1;
        if st > 30 {
            break st;
        }
    };
    //for语句块表达式:不支持返回值
    let ve = vec![1, 3, 2, 4, 57];
    let _ep6 = for item in ve {
        let _ = item + item;
    };
    //white语句块表达式同样不支持返回值
    // *有限循环的break都不能带上一个值作为返回值,有限循环的设计初衷是对循环体内的数据进行操作,而不是返回一个值什么的

    //match语句块表达式:略,见matcher
}
// 注意在rust中就算是堆数据发生变化也要指明mut
